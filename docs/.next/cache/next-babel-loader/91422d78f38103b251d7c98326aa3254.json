{"ast":null,"code":"import * as React from 'react';\n/**\n * React.Ref uses the readonly type `React.RefObject` instead of\n * `React.MutableRefObject`, We pretty much always assume ref objects are\n * mutable (at least when we create them), so this type is a workaround so some\n * of the weird mechanics of using refs with TS.\n */\n\n/**\n * This is a hack for sure. The thing is, getting a component to intelligently\n * infer props based on a component or JSX string passed into an `as` prop is\n * kind of a huge pain. Getting it to work and satisfy the constraints of\n * `forwardRef` seems dang near impossible. To avoid needing to do this awkward\n * type song-and-dance every time we want to forward a ref into a component\n * that accepts an `as` prop, we abstract all of that mess to this function for\n * the time time being.\n *\n * TODO: Eventually we should probably just try to get the type defs above\n * working across the board, but ain't nobody got time for that mess!\n *\n * @param Comp\n */\n\nexport function forwardRefWithAs(comp) {\n  return /*#__PURE__*/React.forwardRef(comp);\n}\n/*\nTest components to make sure our dynamic As prop components work as intended \ntype PopupProps = {\n  lol: string;\n  children?: React.ReactNode | ((value?: number) => JSX.Element);\n};\nexport const Popup = forwardRefWithAs<PopupProps, 'input'>(\n  ({ as: Comp = 'input', lol, className, children, ...props }, ref) => {\n    return (\n      <Comp ref={ref} {...props}>\n        {typeof children === 'function' ? children(56) : children}\n      </Comp>\n    );\n  }\n);\nexport const TryMe1: React.FC = () => {\n  return <Popup as=\"input\" lol=\"lol\" name=\"me\" />;\n};\nexport const TryMe2: React.FC = () => {\n  let ref = React.useRef(null);\n  return <Popup ref={ref} as=\"div\" lol=\"lol\" />;\n};\n\nexport const TryMe4: React.FC = () => {\n  return <Popup as={Whoa} lol=\"lol\" test=\"123\" name=\"boop\" />;\n};\nexport const Whoa: React.FC<{\n  help?: boolean;\n  lol: string;\n  name: string;\n  test: string;\n}> = props => {\n  return <input {...props} />;\n};\n*/\n// export const TryMe3: React.FC = () => {\n//   return <Popup as={Cool} lol=\"lol\" name=\"me\" test=\"123\" />;\n// };\n// let Cool = styled(Whoa)`\n//   padding: 10px;\n// `","map":{"version":3,"sources":["/Users/kamell/Desktop/test-docs/src/components/forwardRefWithAs.js"],"names":["React","forwardRefWithAs","comp","forwardRef"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;AACrC,sBAAOF,KAAK,CAACG,UAAN,CAAiBD,IAAjB,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import * as React from 'react';\n/**\n * React.Ref uses the readonly type `React.RefObject` instead of\n * `React.MutableRefObject`, We pretty much always assume ref objects are\n * mutable (at least when we create them), so this type is a workaround so some\n * of the weird mechanics of using refs with TS.\n */\n\n/**\n * This is a hack for sure. The thing is, getting a component to intelligently\n * infer props based on a component or JSX string passed into an `as` prop is\n * kind of a huge pain. Getting it to work and satisfy the constraints of\n * `forwardRef` seems dang near impossible. To avoid needing to do this awkward\n * type song-and-dance every time we want to forward a ref into a component\n * that accepts an `as` prop, we abstract all of that mess to this function for\n * the time time being.\n *\n * TODO: Eventually we should probably just try to get the type defs above\n * working across the board, but ain't nobody got time for that mess!\n *\n * @param Comp\n */\nexport function forwardRefWithAs(comp) {\n  return React.forwardRef(comp);\n}\n/*\nTest components to make sure our dynamic As prop components work as intended \ntype PopupProps = {\n  lol: string;\n  children?: React.ReactNode | ((value?: number) => JSX.Element);\n};\nexport const Popup = forwardRefWithAs<PopupProps, 'input'>(\n  ({ as: Comp = 'input', lol, className, children, ...props }, ref) => {\n    return (\n      <Comp ref={ref} {...props}>\n        {typeof children === 'function' ? children(56) : children}\n      </Comp>\n    );\n  }\n);\nexport const TryMe1: React.FC = () => {\n  return <Popup as=\"input\" lol=\"lol\" name=\"me\" />;\n};\nexport const TryMe2: React.FC = () => {\n  let ref = React.useRef(null);\n  return <Popup ref={ref} as=\"div\" lol=\"lol\" />;\n};\n\nexport const TryMe4: React.FC = () => {\n  return <Popup as={Whoa} lol=\"lol\" test=\"123\" name=\"boop\" />;\n};\nexport const Whoa: React.FC<{\n  help?: boolean;\n  lol: string;\n  name: string;\n  test: string;\n}> = props => {\n  return <input {...props} />;\n};\n*/\n// export const TryMe3: React.FC = () => {\n//   return <Popup as={Cool} lol=\"lol\" name=\"me\" test=\"123\" />;\n// };\n// let Cool = styled(Whoa)`\n//   padding: 10px;\n// `"]},"metadata":{},"sourceType":"module"}