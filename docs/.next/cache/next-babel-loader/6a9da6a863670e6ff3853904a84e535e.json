{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Returns the siblings of a specific route (that is the previous and next routes).\n */\nexport function getRouteContext(_route, routes, ctx = {}) {\n  if (!_route) {\n    return ctx;\n  }\n\n  const {\n    path\n  } = _route;\n  const {\n    parent\n  } = ctx;\n\n  for (let i = 0; i < routes.length; i += 1) {\n    var _routes;\n\n    const route = routes[i];\n\n    if (route.routes) {\n      ctx.parent = route;\n      ctx = getRouteContext(_route, route.routes, ctx); // If the active route and the next route was found in nested routes, return it\n\n      if (ctx.nextRoute) return ctx;\n    }\n\n    if (!route) continue;\n    if (!route.path) continue;\n\n    if (ctx.route) {\n      ctx.nextRoute = parent && i === 0 ? _objectSpread(_objectSpread({}, route), {}, {\n        title: `${parent.title}: ${route.title}`\n      }) : route;\n      return ctx;\n    }\n\n    if (route && route.path === path) {\n      ctx.route = _objectSpread(_objectSpread({}, _route), {}, {\n        title: parent && !parent.heading ? `${parent.title}: ${_route.title}` : _route.title\n      }); // Continue the loop until we know the next route\n\n      continue;\n    }\n\n    ctx.prevRoute = parent && !parent.heading && !((_routes = routes[i + 1]) !== null && _routes !== void 0 && _routes.path) ? _objectSpread(_objectSpread({}, route), {}, {\n      title: `${parent.title}: ${route.title}`\n    }) : route;\n  } // The loop ended and the previous route was found, or nothing\n\n\n  return ctx;\n}","map":{"version":3,"sources":["/Users/kamell/Desktop/test-docs/src/lib/get-route-context.js"],"names":["getRouteContext","_route","routes","ctx","path","parent","i","length","route","nextRoute","title","heading","prevRoute"],"mappings":";;;;;;AAAA;AACA;AACA;AACA,OAAO,SAASA,eAAT,CAAyBC,MAAzB,EAAiCC,MAAjC,EAAyCC,GAAG,GAAG,EAA/C,EAAmD;AACxD,MAAI,CAACF,MAAL,EAAa;AACX,WAAOE,GAAP;AACD;;AAED,QAAM;AACJC,IAAAA;AADI,MAEFH,MAFJ;AAGA,QAAM;AACJI,IAAAA;AADI,MAEFF,GAFJ;;AAIA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAAM,CAACK,MAA3B,EAAmCD,CAAC,IAAI,CAAxC,EAA2C;AAAA;;AACzC,UAAME,KAAK,GAAGN,MAAM,CAACI,CAAD,CAApB;;AAEA,QAAIE,KAAK,CAACN,MAAV,EAAkB;AAChBC,MAAAA,GAAG,CAACE,MAAJ,GAAaG,KAAb;AACAL,MAAAA,GAAG,GAAGH,eAAe,CAACC,MAAD,EAASO,KAAK,CAACN,MAAf,EAAuBC,GAAvB,CAArB,CAFgB,CAEkC;;AAElD,UAAIA,GAAG,CAACM,SAAR,EAAmB,OAAON,GAAP;AACpB;;AAED,QAAI,CAACK,KAAL,EAAY;AACZ,QAAI,CAACA,KAAK,CAACJ,IAAX,EAAiB;;AAEjB,QAAID,GAAG,CAACK,KAAR,EAAe;AACbL,MAAAA,GAAG,CAACM,SAAJ,GAAgBJ,MAAM,IAAIC,CAAC,KAAK,CAAhB,mCAAyBE,KAAzB;AACdE,QAAAA,KAAK,EAAG,GAAEL,MAAM,CAACK,KAAM,KAAIF,KAAK,CAACE,KAAM;AADzB,WAEZF,KAFJ;AAGA,aAAOL,GAAP;AACD;;AAED,QAAIK,KAAK,IAAIA,KAAK,CAACJ,IAAN,KAAeA,IAA5B,EAAkC;AAChCD,MAAAA,GAAG,CAACK,KAAJ,mCAAiBP,MAAjB;AACES,QAAAA,KAAK,EAAEL,MAAM,IAAI,CAACA,MAAM,CAACM,OAAlB,GAA6B,GAAEN,MAAM,CAACK,KAAM,KAAIT,MAAM,CAACS,KAAM,EAA7D,GAAiET,MAAM,CAACS;AADjF,SADgC,CAG7B;;AAEH;AACD;;AAEDP,IAAAA,GAAG,CAACS,SAAJ,GAAgBP,MAAM,IAAI,CAACA,MAAM,CAACM,OAAlB,IAA6B,aAACT,MAAM,CAACI,CAAC,GAAG,CAAL,CAAP,oCAAC,QAAeF,IAAhB,CAA7B,mCAAyDI,KAAzD;AACdE,MAAAA,KAAK,EAAG,GAAEL,MAAM,CAACK,KAAM,KAAIF,KAAK,CAACE,KAAM;AADzB,SAEZF,KAFJ;AAGD,GA3CuD,CA2CtD;;;AAGF,SAAOL,GAAP;AACD","sourcesContent":["/**\n * Returns the siblings of a specific route (that is the previous and next routes).\n */\nexport function getRouteContext(_route, routes, ctx = {}) {\n  if (!_route) {\n    return ctx;\n  }\n\n  const {\n    path\n  } = _route;\n  const {\n    parent\n  } = ctx;\n\n  for (let i = 0; i < routes.length; i += 1) {\n    const route = routes[i];\n\n    if (route.routes) {\n      ctx.parent = route;\n      ctx = getRouteContext(_route, route.routes, ctx); // If the active route and the next route was found in nested routes, return it\n\n      if (ctx.nextRoute) return ctx;\n    }\n\n    if (!route) continue;\n    if (!route.path) continue;\n\n    if (ctx.route) {\n      ctx.nextRoute = parent && i === 0 ? { ...route,\n        title: `${parent.title}: ${route.title}`\n      } : route;\n      return ctx;\n    }\n\n    if (route && route.path === path) {\n      ctx.route = { ..._route,\n        title: parent && !parent.heading ? `${parent.title}: ${_route.title}` : _route.title\n      }; // Continue the loop until we know the next route\n\n      continue;\n    }\n\n    ctx.prevRoute = parent && !parent.heading && !routes[i + 1]?.path ? { ...route,\n      title: `${parent.title}: ${route.title}`\n    } : route;\n  } // The loop ended and the previous route was found, or nothing\n\n\n  return ctx;\n}"]},"metadata":{},"sourceType":"module"}